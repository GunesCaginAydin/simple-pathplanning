function [parent_update, parent_change, cost_min, min_par_indx, col, parent_idx_no_col] = update_parent_rrtstar(tev, neigh_parent_list, neigh_parent_idx,fconfig_spc) % possibility to write a collision check function
    parent_change = 0;
    col = 0;
    tree_len = length(tev);
    config = tev(tree_len).vertex;   
    parent_old = tev(tree_len).parent;

    % parents that are connectable candidates
    [parent_list_no_col, parent_idx_no_col]= col_check(config, neigh_parent_list, neigh_parent_idx, fconfig_spc); % for the neigh parent list - determine parent coords with no collision
    if isempty(parent_list_no_col)
        col = 1; parent_update = 0; cost_min = 0; min_par_indx = 0; parent_idx_no_col = 0;
        return
    end
    %final candidate parents cost check 
    cost_list_no_col = tree_interp_cost(tev, parent_idx_no_col); % cost of no collision parent
    
    % additional cost of proposed new configuration
    cost_add_no_col = dist(config, parent_list_no_col);

    % new cost list
    cost_list_prov = cost_list_no_col + cost_add_no_col'; % FIX

    %cost minimization RRT
    [cost_min, min_par_indx] = min(cost_list_prov,[],'all');
    
    %cost_list(min_par_indx) = cost_min;
    parent_update = parent_idx_no_col(min_par_indx);

    if parent_update ~= parent_old
        parent_change = 1;
    elseif parent_update == parent_old
        return
    end

    function [col_free_parents_coord, col_free_parent_idx]= col_check(vertex,parents,parent_idx,config_space) % checks new parents for possible collisions
        lent = size(parents,1);
        col_free_parents_coord = [];
        col_free_parent_idx = [];
        for p = 1:lent
            space_ext_c = squeeze(abs(parents(p,2) - vertex(2)));
            space_ext_r = squeeze(abs(parents(p,1) - vertex(1)));
            space_ext_param = max([space_ext_c;space_ext_r]);
    
            configc_run = round(linspace(parents(p,2),vertex(2),space_ext_param));
            configr_run = round(linspace(parents(p,1),vertex(1),space_ext_param));
            configxy = [configr_run' configc_run'];
            line_idx = sub2ind(size(config_space), configxy(:,1), configxy(:,2));

            if any(config_space(line_idx) == 0)
                continue
            elseif all(config_space(line_idx) == 1)
                parent_coord = parents(p,:);
                col_free_parents_coord = [col_free_parents_coord; parent_coord];
                col_free_parent_idx = [col_free_parent_idx; parent_idx(p)];
            end
        end
    end

    function cost_list = tree_interp_cost(tree, idx)
        pparam = length(idx);
        cost_list = [];
        for j = 1:pparam
            cost_list(j) = tree(idx(j)).totcost;
        end
        
    end

    % function cost_list = tree_interp_cost(tree, col_free_pcoords)
    %     tparam = length(tree);
    %     pparam = size(col_free_pcoords,1);
    %     idx = [];
    %     cost_list = [];
    %     for j = 1:tparam
    %         for i = 1:pparam
    %             if all(tree(j).vertex == col_free_pcoords(i,:))
    %                 idx = [idx; j];
    %                 cost_list = [cost_list; tree(j).totcost];
    %             else
    %                 continue
    %             end
    %         end
    % 
    %     end
    % 
    % end

    function dist_add = dist(vertex, parent)
        lentn = size(parent,1);
        for k = 1:lentn
            vec = vertex - parent(k);
            dist_add(k) = norm(vec);
        end
    end
end



